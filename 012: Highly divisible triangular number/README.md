# Highly divisible triangular number

## Problem statement

```
The sequence of triangle numbers is generated by adding the natural numbers. So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The first ten terms would be:

1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...

Let us list the factors of the first seven triangle numbers:

     1: 1
     3: 1,3
     6: 1,2,3,6
    10: 1,2,5,10
    15: 1,3,5,15
    21: 1,3,7,21
    28: 1,2,4,7,14,28

We can see that 28 is the first triangle number to have over five divisors.

What is the value of the first triangle number to have over five hundred divisors?
```

## Initial thoughts

* Iterator for triangle numbers (using `count()` to get an iterator for the natural numbers)
* `fn divisors(num: uint) -> Vec<uint>`

## First solution

I'm satisfied with this. `divisors` took a bit of figuring out: I initially implemented the naive method of doing `num % i == 0` on `range(2, num)` but that was incredibly slow, of course. It was so slow that even running the program for over 10 minutes didn't yield a solution.

After some Internet searches on fast divisor-finding algorithms, I was pointed in the right direction which is something I should have remembered from my `is_prime` function several problems back. To find a list of factors, it's only necessary to check up to the square root of a number since any factor greater than the sqrt will be a composite of two previous factors.

```rust
use std::iter::range_inclusive;

fn main() {
    let mut iter = triangle_numbers()
        .map(|n| NumberWithDivisors{ number: n, divisors: divisors(n) })
        .skip_while(|x| x.divisors.len() <= 500 );

    for n in iter {
        println!("{} -> {}", n.number, n.divisors);
        break
    }
}

struct NumberWithDivisors {
    number: u64,
    divisors: Vec<u64>,
}

fn triangle_numbers() -> TriangleNumberIter {
    TriangleNumberIter { idx: 0, prev: 0 }
}
struct TriangleNumberIter {
    idx: u64,
    prev: u64,
}
impl Iterator<u64> for TriangleNumberIter {
    fn next(&mut self) -> Option<u64> {
        self.idx += 1;
        let result = self.idx + self.prev;
        self.prev = result;
        Some(result)
    }
}

fn divisors(num: u64) -> Vec<u64> {
    let mut result = vec![1];
    let sqrt = (num as f64).sqrt().ceil() as u64;
    for i in range_inclusive(2, sqrt) {
        if num % i == 0 {
            result.push(i);
            result.push(num / i);
        }
    }
    result.push(num);
    result
}
```